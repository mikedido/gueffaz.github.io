<!DOCTYPE html>
<html lang="fr">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Language" content="fr">

    <meta name="author" content="Mahdi GUEFFAZ">
    <meta name="description" content="L&#39;idée générale de l&#39;approche ScaleSem est de vérifier les propriétés et d&#39;interroger les graphes sémantiques. Pour cela, nous proposons des outils de traitement et d&#39;interrogation de la vérification de modèle basée sur des graphes sémantiques dans cette thèse.">
    <meta name="keywords" content="blog,developer,personal">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="ScaleSem"/>
<meta name="twitter:description" content="L&#39;idée générale de l&#39;approche ScaleSem est de vérifier les propriétés et d&#39;interroger les graphes sémantiques. Pour cela, nous proposons des outils de traitement et d&#39;interrogation de la vérification de modèle basée sur des graphes sémantiques dans cette thèse."/>

    <meta property="og:title" content="ScaleSem" />
<meta property="og:description" content="L&#39;idée générale de l&#39;approche ScaleSem est de vérifier les propriétés et d&#39;interroger les graphes sémantiques. Pour cela, nous proposons des outils de traitement et d&#39;interrogation de la vérification de modèle basée sur des graphes sémantiques dans cette thèse." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://mikedido.github.io/fr/projects/scalesem/" />
<meta property="article:published_time" content="2013-11-15T00:00:00+00:00" />
<meta property="article:modified_time" content="2013-11-15T00:00:00+00:00" />




    <title>
  ScaleSem · $ cd /home/
</title>

    
      <link rel="canonical" href="http://mikedido.github.io/fr/projects/scalesem/">
    

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fork-awesome/1.1.7/css/fork-awesome.min.css" integrity="sha512-9QjPqX/aCNwEQDyMqqMluNOSsHxTwOJNO3d4m5aUeNbyOPm8RcBA5hCUhvGmKFtSmQYGajqPopGtD60FWiWUwg==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha512-NhSC1YmyruXifcj/KFRWoC561YpHpc5Jtzgvbuzx5VozKpWvQ+4nXhPdFgmx8xqexRcpAglTj9sIBWINXa8x5w==" crossorigin="anonymous" />
    
      
      
      <link rel="stylesheet" href="/css/coder.min.c86383fb6d4c1f21196659450b74100986ea2356bcfc18b583c3534d92a2239f.css" integrity="sha256-yGOD&#43;21MHyEZZllFC3QQCYbqI1a8/Bi1g8NTTZKiI58=" crossorigin="anonymous" media="screen" />
    

    

    
      
        
        
        <link rel="stylesheet" href="/css/coder-dark.min.127a8585f14f079da5d6160b6afb7a50f462765a6a55868b99afea9dd9e72d51.css" integrity="sha256-EnqFhfFPB52l1hYLavt6UPRidlpqVYaLma/qndnnLVE=" crossorigin="anonymous" media="screen" />
      
    

    

    

    <link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

    <link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/twemoji/12.0.4/2/twemoji.min.js" integrity="sha512-panBjUGuKarjg0qxHggQULmRf9jB/YVCy238hmzBWUuLeOuwMSuJgJcUv3T+rwXUBZ9zeUvc49ZcCRH+EO0H8g==" crossorigin="anonymous"></script>
    

    <meta name="generator" content="Hugo 0.79.0" />
  </head>

  
  
    
  
  <body class="colorscheme-auto"
        onload=" twemoji.parse(document.body); "
  >
    
    <main class="wrapper">
      <nav class="navigation" id="navigation">
  <section class="container">
    <a class="navigation-title" href="/fr">
      <span class="logo__mark">&gt;</span>
      <span class="logo__text">$ cd /home/</span>
      <span class="logo__cursor"></span>
    </a>
    
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link" href="/fr/posts/">Blog</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/fr/projects/">Projets</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/fr/contact/">Contact</a>
            </li>
          
        
        
          
          
          
            
              
                <li class="navigation-item menu-separator">
                  <span>|</span>
                </li>
                
              
              <li class="navigation-item">
                <a href="http://mikedido.github.io/projects/scalesem/">En</a>
              </li>
              <li class="navigation-item menu-separator">
                <span>|</span>
              </li>
              <li id="dark-mode-toggle" class="navigation-item">
                <a >
                  <i class="fa fa-adjust fa-fw" aria-hidden="true"></i>
                </a>
                  
              </li>
            
          
        
      </ul>
    
  </section>
</nav>


      <div class="content">
        
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">ScaleSem</h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa fa-calendar" aria-hidden="true"></i>
              <time datetime='2013-11-15T00:00:00Z'>
                November 15, 2013
              </time>
            </span>
            
              <span class="reading-time">
                <i class="fa fa-clock-o" aria-hidden="true"></i>
                20 minutes de lecture
              </span>
            
          </div>
          <div class="authors">
    <i class="fa fa-user" aria-hidden="true"></i>
      <a href="/fr/authors/mahdi-gueffaz/">Mahdi Gueffaz</a></div>
          
          
        </div>
      </header>

      <div>
        
        <p><img src="https://img.shields.io/badge/v1.6-Java-green" alt="Java">
<img src="https://img.shields.io/badge/v2.4-Jena-green" alt="Jena">
<img src="https://img.shields.io/badge/v1.1-RDF-green" alt="RDF">
<img src="https://img.shields.io/badge/v2.0-OWL-yellow" alt="OWL">
<img src="https://img.shields.io/badge/v1.1-SPARQL-yellow" alt="SPARQL">
<img src="https://img.shields.io/badge/v2.4.3-NuSMV-yellow" alt="NuSMV">
<img src="https://img.shields.io/badge/v4.0-SPIN-yellow" alt="SPIN">
<img src="https://img.shields.io/badge/LTL-yellow" alt="LTL">
<img src="https://img.shields.io/badge/CTL-yellow" alt="CTL">
<img src="https://img.shields.io/badge/v3.0-C++-yellow" alt="C++"></p>
<h1 id="sommaire-">Sommaire :</h1>
<ol>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#qualification-des-graphes-s%C3%A9mantiques">Qualification des graphes sémantiques</a>
<ul>
<li><a href="#section-2-1">2.1. Les étapes de transformation</a>
<ul>
<li><a href="#section-2-1-1">2.1.1 Exploration du graphe</a></li>
<li><a href="#section-2-1-2">2.1.2 Détermination d&rsquo;une racine</a></li>
<li><a href="#section-2-1-3">2.1.3 Génération du modèle</a></li>
</ul>
</li>
<li><a href="#section-2-2">2.2. La vérification</a></li>
</ul>
</li>
<li><a href="#interrogation-des-graphes-s%C3%A9mantiques">Interrogation des graphes sémantiques</a></li>
<li><a href="#la-methodologie-CLOCK">La méthodologie CLOCK</a></li>
<li><a href="#conclusion">Conclusion</a></li>
<li><a href="#publications">Publications</a></li>
<li><a href="#liens">Liens</a></li>
<li><a href="#remerciements">Remerciements</a></li>
</ol>
<h2 id="introduction">Introduction</h2>
<p>Le développement croissant des réseaux et en particulier l&rsquo;Internet a considérablement développé l&rsquo;écart entre les systèmes d&rsquo;information hétérogènes. En faisant une analyse sur les études de l&rsquo;interopérabilité des systèmes d&rsquo;information hétérogènes, nous découvrons que tous les travaux dans ce domaine tendent à la résolution des problèmes de l&rsquo;hétérogénéité sémantique. Le <a href="https://www.w3.org/">W3C</a> (World Wide Web Consortium) propose des normes pour représenter la sémantique par l&rsquo;ontologie. L&rsquo;ontologie est en train de devenir un support incontournable pour l&rsquo;interopérabilité des systèmes d&rsquo;information et en particulier dans la sémantique. La structure de l&rsquo;ontologie est une combinaison de concepts, propriétés et relations. Cette combinaison est aussi appelée un graphe sémantique. Plusieurs langages ont été développés dans le cadre du <a href="https://fr.wikipedia.org/wiki/Web_s%C3%A9mantique#:~:text=Le%20Web%20s%C3%A9mantique%2C%20ou%20toile,Resource%20Description%20Framework%20(RDF)">Web sémantique</a> et la plupart de ces langages utilisent la syntaxe <a href="https://fr.wikipedia.org/wiki/Extensible_Markup_Language">XML</a> (eXtensible Meta Language). Les langages <a href="https://fr.wikipedia.org/wiki/Web_Ontology_Language">OWL</a> (Ontology Web Language) et <a href="https://fr.wikipedia.org/wiki/Resource_Description_Framework">RDF</a> (Resource Description Framework) sont les langages les plus importants du web sémantique, ils sont basés sur XML.</p>
<p>Le RDF est la première norme du W3C pour l&rsquo;enrichissement des ressources sur le Web avec des descriptions détaillées et il augmente la facilité de traitement automatique des ressources Web. Les descriptions peuvent être des caractéristiques des ressources, telles que l&rsquo;auteur ou le contenu d&rsquo;un site web. Ces descriptions sont des métadonnées. Enrichir le Web avec des métadonnées permet le développement de ce qu&rsquo;on appelle le Web Sémantique. Le RDF est aussi utilisé pour représenter les graphes sémantiques correspondant à une modélisation des connaissances spécifiques. Les fichiers RDF sont généralement stockés dans une base de données relationnelle et manipulés en utilisant le langage SQL ou les langages dérivés comme SPARQL. Malheureusement, cette solution, bien adaptée pour les petits graphes RDF n&rsquo;est pas bien adaptée pour les grands graphes RDF. Ces graphes évoluent rapidement et leur adaptation au changement peut faire apparaître des incohérences. Conduire l’application des changements tout en maintenant la cohérence des graphes sémantiques est une tâche cruciale et coûteuse en termes de temps et de complexité. Un processus automatisé est donc essentiel. Pour ces graphes RDF de grande taille, nous suggérons une nouvelle façon en utilisant la vérification formelle « Le Model checking ».</p>
<p>Le Model checking est une technique de vérification qui explore tous les états possibles du système. De cette manière, on peut montrer qu’un modèle d’un système donné satisfait une propriété donnée. Cette thèse apporte une nouvelle méthode de vérification et d’interrogation de graphes sémantiques. Nous proposons une approche nommé ScaleSem qui consiste à transformer les graphes sémantiques en graphes compréhensibles par le model checker (l’outil de vérification de la méthode Model checking). Il est nécessaire d’avoir des outils logiciels permettant de réaliser la traduction d’un graphe décrit dans un formalisme vers le même graphe (ou une adaptation) décrit dans un autre formalisme.</p>
<h2 id="qualification-des-graphes-sémantiques">Qualification des graphes sémantiques</h2>
<p>Après avoir présenté plusieurs model checkers, nous avons choisi les model checkers SPIN et NuSMV qui utilisent des automates non temporisés c&rsquo;est-à-dire que la notion de temps n’est pas prise en compte dans les arêtes de nos modèles. Ce modèle non temporisé est approprié dans notre approche, puisque un graphe sémantique ne prend pas en compte le temps (ou n’a pas besoin de variable de temps) pour passer d’un état du graphe à un autre. Les model checkers SPIN et NuSMV sont les plus utilisés dans le domaine de la vérification qualitative.</p>
<p>Notre approche qui consiste à transformer des graphes sémantiques en modèles afin d&rsquo;être vérifiés par le model checker. Cette approche de transformation et de vérification est nommée « ScaleSem ». Pour cela, nous avons développé deux outils appelés <em>RDF2SPIN</em> et <em>RDF2NuSMV</em> (ces deux outils ont été déposés à l’Agence pour la Protection des Programmes <a href="https://www.app.asso.fr/nos-solutions/deposer">APP</a>), qui transforment les graphes sémantiques respectivement dans le langage PROMELA et dans le langage SMV.</p>
<h3 id="les-étapes-de-transformation-a-idsection-2-1a">Les étapes de transformation <a id="section-2-1"></a></h3>
<p>La transformation de graphe sémantique en un modèle est la première phase de l’approche ScaleSem. Cette phase consiste à représenter le graphe sémantique sous une autre forme, afin de permettre au Model Checher de le vérifier. Les différentes étapes de cette transformation sont :</p>
<h6 id="exploration-du-graphe--a-idsection-2-1-1a">Exploration du graphe : <a id="section-2-1-1"></a></h6>
<p>Afin d&rsquo;exploiter les graphes sémantiques, nous devons déterminer s’ils ont un sommet racine. Dans le cas contraire, nous devons créer une nouvelle racine, pointant vers chacun des sommets racines précédents, en prenant soin de garder la taille du graphe obtenu, la plus petite possible.</p>
<p><img src="/images/projects/scalesem/algo_dfs.png" alt="" style="display: block; margin-left: auto; margin-right: auto;height: 360px !important;width: 617px !important;" ></p>
<p>Prenons un graphe sémantique représenté sous forme d’un couple <em>(V, E)</em>, où <em>V</em> est l&rsquo;ensemble des sommets et <em>E</em> inclut dans <em>V x V</em> l&rsquo;ensemble des arêtes. Pour un sommet <em>x</em>, on note <em><strong>E(x) = {y ∈ V | (x,y) ∈ E}</strong></em>  l&rsquo;ensemble de ses sommets successeurs, et nous supposons que ces sommets sont classés à partir de <em><strong>E(x)<sub>0</sub></strong></em> jusqu&rsquo;à <em><strong>E(x)<sub>|E(x)|-1</sub></strong></em>. Cela correspond à la structure de données classique pour représenter des graphes en mémoire, consistant en un tableau indexé par les sommets et contenant dans chaque entrée la liste des sommets successeurs du sommet correspondant. Il existe plusieurs algorithmes pour parcourir de grands graphes. Parmi eux, la recherche en profondeur d’abord (DFS) et la recherche en largeur d’abord (BFS) sont les plus connus. L&rsquo;algorithme d&rsquo;exploration de base que nous utilisons est l’algorithme de recherche en profondeur d&rsquo;abord (DFS), illustré ci-dessous pour explorer le graphe (voir le algorithme ci-dessous), tout en sachant que l’algorithme en largeur d’abord fonctionne
également dans ce contexte. Nous avons considéré ici une variante itérative du DFS, utilisant une pile explicite, plutôt que la variante récursive. Ceci est nécessaire dans la pratique pour éviter les débordements de la pile d’appels du système lorsque l&rsquo;algorithme est invoqué pour explorer de grands graphes.</p>
<h6 id="détermination-dune-racine--a-idsection-2-1-2a">Détermination d&rsquo;une racine : <a id="section-2-1-2"></a></h6>
<p>Si le graphe sémantique n&rsquo;a pas de sommet racine, nous devons en créer un nouveau en tant que successeur ayant tous les sommets du graphe, mais cela augmenterait le nombre d&rsquo;arêtes. Nous cherchons donc à effectuer cette opération en ajoutant le moins d’arêtes possible. Un sommet d&rsquo;un graphe orienté est une racine partielle s’il ne peut pas être atteint à partir de n&rsquo;importe quel autre sommet du graphe. Si le graphe ne contient qu&rsquo;une seule racine partielle, tous les autres sommets du graphe peuvent être atteints de la racine, sinon il y aurait d&rsquo;autres racines partielles dans le graphe. Si le graphe a de multiples racines partielles, la façon la plus économique de fournir une racine est d’en créer une nouvelle avec toutes les racines en tant que successeur partiel : cela permettra d&rsquo;ajouter au graphe un nombre minimal d&rsquo;arrêtes.</p>
<p><img src="/images/projects/scalesem/algo_root.png" alt="" style="display: block; margin-left: auto; margin-right: auto;height: 460px !important;width: 617px !important;" ></p>
<p>Dans l&rsquo;algorithme ci-dessus, nous calculons l&rsquo;ensemble des racines partielles en deux phases, chacune consistant en une exploration successive du graphe. La première phase identifie un ensemble de racines partielles candidates, et la seconde affine cet ensemble afin de déterminer les racines partielles du graphe.</p>
<p>La première phase explore le graphe jusqu&rsquo;à ce qu’il soit entièrement exploré, et insère dans root_list tous les sommets sans prédécesseur. Si root_list contient un seul sommet alors c&rsquo;est la racine (globale) du graphe puisque tous les autres sommets sont accessibles à partir de lui et il est inutile de passer à la deuxième phase. Sinon, n&rsquo;importe quel sommet contenu dans root_list pourrait également être une racine partielle : le rôle de la deuxième phase consiste à déterminer laquelle de ces racines partielles candidates est en effet la racine globale du graphe.
La deuxième phase (voir la Figure 32(b)) effectue une nouvelle vague d&rsquo;explorations successives de l’algorithme DFS des racines partielles contenues dans root_list dans l&rsquo;ordre inverse dans lequel elles ont été insérées dans la liste. Si une racine dans root_list peut être visitée par une racine partielle de la liste, elle est retirée de la liste parce qu&rsquo;elle n&rsquo;est pas une racine partielle. À la fin de cette phase, toutes les racines partielles présentes dans root_list sont des racines partielles. En effet, chaque sommet est inaccessible à partir de l&rsquo;un des candidats racines partielles dans root_list. Une racine est créée (Figure 33), ayant en tant que successeur toutes les racines partielles de root_list, garantissant ainsi que tous les sommets du graphe sont accessibles à partir de la nouvelle racine. Par conséquent, un tel sommet est inaccessible à partir d&rsquo;autres nœuds du graphe.</p>
<p>L&rsquo;algorithme pour déterminer une racine dispose d&rsquo;une complexité , linéaire dans la taille du graphe (nombre de sommets et d&rsquo;arêtes), étant donné que chaque phase visite chaque état et parcours chaque arrête du graphe qu&rsquo;une seule fois. Étant donné que le graphe doit être parcouru entièrement, afin de déterminer s’il a une racine ou non.</p>
<h6 id="génération-du-modèle--a-idsection-2-1-3a">Génération du modèle : <a id="section-2-1-3"></a></h6>
<p>La troisième et dernière étape est divisée en trois sous-étapes. La première et la deuxième génèrent deux tables : une table des triplets et une autre table qui dépendra de l’outil utilisé RDF2SPIN ou RDF2NuSMV. La dernière sous-étape produira le modèle du graphe sémantique écrit dans le langage d’entrée du model checker.</p>
<ul>
<li>
<p><strong>Table des triplets</strong> - En parcourant le graphe RDF par des algorithmes de parcours de graphes (parcours en profondeur ou en largeur), nous créons une table constituée de ressources, de propriétés et de valeurs. Dans notre graphe sémantique, la ressource est un sommet, la propriété représente une arête et la valeur est le sommet successeur correspondant à l’arête du sommet. La table de triplets du graphe sémantique est utile pour la prochaine étape.</p>
</li>
<li>
<p>Dans cette deuxième sous-étape, RDF2SPIN génère un tableau des ressources et des valeurs, tandis que RDF2NuSMV génère une table de correspondances.</p>
<ul>
<li><strong>Table des ressources et des valeurs</strong> – Pendant le parcours de la table des triplets, vu dans l&rsquo;étape précédente, nous attribuons à chaque ressource et à chaque valeur une fonction unique. Ces fonctions sont de type proctype. Nous combinons toutes ces fonctions dans une table appelée table des ressources et des valeurs.</li>
<li><strong>Table de correspondance</strong> – dans cette étape, nous attribuons pour chaque ressource ses messages suivants (les prédicats) et ses états suivants (valeurs).</li>
</ul>
</li>
<li>
<p><strong>Le modèle de graphe</strong> - Dans cette dernière sous-étape, nous écrirons le modèle correspondant au graphe sémantique que nous voulons vérifier. Le modèle sera écrit en langage PROMELA si nous utilisons l’outil de transformation RDF2SPIN et en langage SMV
avec l’outil RDF2NuSMV.</p>
</li>
</ul>
<h3 id="la-vérification-a-idsection-2-2a">La vérification <a id="section-2-2"></a></h3>
<p>La deuxième phase de notre approche est la vérification. Elle est assurée par le model checker. Après avoir transformé le graphe sémantique en un modèle compréhensible par le model checker, nous pouvons écrire les propriétés à vérifier en logique temporelle. Nous passons au model checker le modèle du graphe sémantique et les propriétés à vérifier. Le model checker vérifiera une à une les propriétés et retournera vrai si la propriété est vérifiée, ou faux avec un contre-exemple dans le cas contraire.</p>
<p>Cette phase de qualifaction nous a poussé à developper deux outils de transformation de graphes sémantiques en modeles interprétable par les outils du Model Checker. Ces deux outilis ont fait l’objet d’un dépôt APP. Pourquoi deux outils ? deux type de logique temporelles CTL et LTL. La CTL est interpereté par NuSMV tandis que la LTL par SPIN.</p>
<p>L’outil RDF2NuSMV qui permet la transformation de graphes sémantiques vers un modèle de graphes en langage SMV, prenant en considération toutes les étapes de transformations décrites précédemment. Cet outil a été développé en langage C++.
L’outil RDF2SPIN transforme des graphes sémantiques vers le langage PROMELA. Cet outil a été développé avec le langage C++, sous l’environnement Linux. RDF2SPIN analyse le graphe sémantique avant de le convertir en modèle SPIN (Langage PROMELA), afin de s’assurer de l’absence de toute erreur dans le graphe sémantique.</p>
<h2 id="interrogation-des-graphes-sémantiques">Interrogation des graphes sémantiques</h2>
<p>Dans le domaine du Web sémantique, plusieurs approches ont été proposées pour l’interrogation des graphes, la plupart d&rsquo;entre elles ayant conduit à des langages standardisés par le W3C, tels que XPath, XQuery et SPARQL. Diverses extensions de SPARQL ont été proposées afin d&rsquo;augmenter son expressivité. Plusieurs langages d&rsquo;interrogation de données RDF ont été proposés et mis en œuvre. Une étude sur les langages de requêtes RDF, menée par le W3C, a identifié plus de 20 langages en cours de développement ou mis en place.
Pour certains, ils sont dans la lignée des langages d&rsquo;interrogations de bases de données traditionnels (comme par exemple SQL (Structured Query Language) ou encore OQL (Object Query Language)). Pour les autres, ils sont basés sur des langages logiques et de règles.</p>
<p>Le langage SPARQL est devenu le langage standard pour l’interrogation des graphes sémantiques, mais ses limites ont été démontrées. Notre objectif de recherche principal est de définir un langage de requêtes puissant et expressif pour les graphes sémantiques, tout en gardant ce langage assez simple pour qu&rsquo;il puisse être facilement intégré et compris. Nous proposons une extension/amélioration du langage de requêtes SPARQL avec les opérateurs des propriétés en logique temporelle, permettant de combler les lacunes de SPARQL dans les graphes sémantiques. Pour atteindre cet objectif, nous avons utilisé la technologie disponible dans l’approche ScaleSem pour la vérification des graphes sémantiques.</p>
<p>L’outil STL-Resolver a fait l’objet d’un dépôt APP, suite à son développement par l’équipe et moi-même pendant ma thèse. C’est un moteur de requêtes pour les modèles de graphes sémantiques qui utilise les requêtes en logiques temporelles en se basant sur les algorithmes de parcours du model checker NuSMV. NuSMV a été notre choix pour l’implémentation du STL-Resolver par rapport au model checker SPIN en raison de ses avantages multiples :</p>
<ul>
<li>nos modèles de graphes sémantiques en langage SMV ne sont pas limités en nombre d’états ;</li>
<li>la vérification se fait directement, sans passer par un compilateur intermédiaire;</li>
<li>il implémente les deux types de logiques temporelles : la logique temporelle linéaire et la logique temporelle arborescente pour la vérification;</li>
</ul>
<p><img src="/images/projects/scalesem/stl_resolver.png" alt="" style="display: block; margin-left: auto; margin-right: auto;height: 460px !important;width: 617px !important;" ></p>
<p>L’architecture de la figure ci-dessus explique le fonctionnement de l’outil STL-Resolver. Dans un premier temps, le modèle du graphe sémantique (ou graphe) est écrit en langage SMV par l’outil RDF2NuSMV. Dans un second temps, l’outil STL Resolver prend en entrée le modèle du graphe sémantique et une requête en logique temporelle. Cet outil récupérera tous les états du modèle et transforme la requête en logique temporelle en une liste de formules de logiques temporelles (c&rsquo;està-dire sans variable ou joker dans la requête) en remplaçant à chaque fois la variable de la requête en logique temporelle par un état de notre graphe. Ensuite, toutes les formules seront testées, en les donnant en paramètre au model checker NuSMV. Si la formule est juste, donc l’état remplaçant la variable de la requête est une solution, sinon un autre état sera cherché (s’il en reste) et le processus décrit ci-dessus sera réitéré.</p>
<p><img src="/images/projects/scalesem/alog_resolution_requetes.png" alt="" style="display: block; margin-left: auto; margin-right: auto;height: 460px !important;width: 617px !important;" ></p>
<p>L’algorithme de résolution traite chaque triplet de la requête en logique temporelle. Si la variable dans le triplet est l’objet, alors la solution sera le successeur du Sujet. Mais cela dépendra également du nombre d’apparitions de l’opérateur Next. Si celui-ci apparaît deux fois, alors la solution sera le successeur du successeur du Sujet. Dans le cas où la variable est le sujet, alors la solution sera les prédécesseurs de l’objet. Enfin, la fonction successeur retourne les nœuds successeurs au nœud donné en paramètre.</p>
<p>Nous avons aussi introduit un nouvel outil SPARQL2RLT pour transformer les requêtes en langage SPARQL en requêtes utilisant les opérateurs de la logique temporelle linéaire (LTL) ouarborescente (CTL). L’objectif final de ces transformations est de résoudre les lacunes des requêtes SPARQL sur les gros graphes et plus précisément sur les jointures. Ce problème fait actuellement l’objet de recherches intensives pour réduire le temps d’interrogation des gros graphes.</p>
<p><img src="/images/projects/scalesem/algo_sparql2rlt.png" alt="" style="display: block; margin-left: auto; margin-right: auto;height: 460px !important;width: 617px !important;" ></p>
<p>Cette algorithme transforme les requêtes en langage SPARQL en requête utilisant les opérateurs de la logique temporelle linéaire et arborescenete. La transformation dépend de la requête SPARQL. Si c’est une requête de type projection, jointure ou union, nous transformons chaque triplet de la requête en un triplet utilisant les opérateurs de la logique temporelle avec la fonction Triplet définie dans le Script 23 ci-dessous et nous les séparerons avec l’opérateur &amp;. Par contre, si la requête SPARQL est de type optional, comme cette forme ajoutera des informations au résultat de la requête SPARQL, la requête en logique temporelle fera précéder tous les triplets contenus dans la partie OPTIONAL de la requête par le mot clé Eventually. Ce mot clé ajoutera les informations si elles existent dans le modèle du graphe sémantique.</p>
<p><img src="/images/projects/scalesem/algo_triplet.png" alt="" style="display: block; margin-left: auto; margin-right: auto;height: 460px !important;width: 617px !important;" ></p>
<p>L’algorithme Triplet décrit ci-dessus, traite chaque triplet de la requête SPARQL. Le prédicat de chaque triplet sera remplacé par -&gt;, le sujet restera toujours le même et l’objet aussi sauf si c’est une variable. Dans ce cas, il sera remplacé par Next Next variable. Dans le cas où nous avons une sélection sur le prédicat, nous remplacerons le prédicat par -&gt; et l’objet par un Next variable. La dernière partie de cet algorithme est la partie optimisation. Elle sert à réduire le nombre de triplets dans la requête en logique temporelle.</p>
<p>L’outil SPARQL2RLT (dépôt APP) transforme les requêtes SPARQL en requêtes utilisant les opérateurs de la logique temporelle. Pour le développement de cet outil, nous avons décidé d’utiliserLEX &amp; YACC pour la décomposition de la requête SPARQL en arbre afin de faciliter la transformation. LEX sert à reconnaître les entités lexicales et à les remplacer par des mots clé qui seront reconnus dans la grammaire du langage défini dans la grammaire écrite en syntaxe YACC (Yet Another Compiler Compiler). Par la suite, YACC va reconnaître et vérifier si les expressions respectent ou non cette grammaire. LEX &amp; YACC sont deux outils très performants, facilitant l’analyse lexicale et syntaxique, respectivement deux étapes difficiles de la compilation.</p>
<p>Le langage SPARQL se caractérise par sa complexité et a plusieurs limites. Le but des travaux de recherches présentés ici dans le domaine de l’interrogation des données du web sémantique est d’améliorer certaines lacunes identifiées précédemment. Pour cela, nous avons utilisé les requêtes en logique temporelle pour simplifier les requêtes SPARQL et obtenir une plus grande expressivité avec les opérateurs en logiques temporelles. L’avantage des formules en logique temporelle est leur facilité d’utilisation et leur puissance d’expression des formules de vérification sur les modèles de graphes sémantiques.</p>
<p>Les algorithmes du model checking sont très performants pour le parcours des graphes, mais ils sont confrontés au problème de l’explosion combinatoire. Notre approche pour l’interrogation des graphes sémantiques, n’a pas donné de très bons résultats en termes de rapidité, mais elle permet d’ajouter de l’expressivité et la simplicité aux requêtes en langage SPARQL.</p>
<h2 id="la-méthodologie-clock">La méthodologie CLOCK</h2>
<p>Le web sémantique est un environnement dynamique, multi-acteurs et distribué. La conception d’ontologie est un travail lent et difficile. Néanmoins, comme tout modèle basé sur une conceptualisation du monde réel, l’ontologie doit s’adapter au changement et évoluer. Les raisons du changement sont multiples. Par exemple : le domaine de définition peut changer, l’ontologie peut être utilisée pour des tâches différentes que celles définies initialement &hellip;</p>
<p>Les travaux sur l’évolution des ontologies, cruciaux pour le développement du web sémantique, sont récents. L’évolution d’une ontologie passe par plusieurs étapes dont l’étape de changement qui consiste à modifier l’ontologie pour prendre en compte les évolutions du domaine qu’elle modélise. L’adaptation de l’ontologie au changement peut faire apparaitre deux types de problèmes : l’incohérence et l’inconsistance. L’incohérence est détectée lorsqu’il existe une interprétation possible de cette ontologie qui soit un modèle, mais que ce modèle sous-jacent associe à certaines classes un ensemble d’instances qui sera toujours vide. C&rsquo;est-à-dire qu’aucun objet ne pourra jamais être une instance de cette classe. Ce type de classes est appelé classe insastifiable. L’inconsistance est détectée lorsqu’il n’existe aucune interprétation possible de l’ontologie qui soit un modèle pour cette ontologie. Conduire l’application des changements tout en maintenant la cohérence de l’ontologie est une tâche cruciale et coûteuse en termes de temps et de complexité. Un processus automatisé est donc essentiel.</p>
<p>Nous nous intéressons aux problèmes de la gestion des changements d’une ontologie. Pour répondre à ces problèmes, nous proposons une nouvelle méthodologie <strong>CLOCk</strong> (<em>Change Log Ontology Checker</em>) basée sur une méthode formelle et le model checking. Cette méthode s’appuie sur une modélisation à l’aide des patrons d’inconsistances pour la détection et la correction de l’incohérence provoqués pendant le processus d’évolution d’ontologie.</p>
<p><img src="/images/projects/scalesem/clock_identification.png" alt="" style="display: block; margin-left: auto; margin-right: auto;height: 460px !important;width: 317px !important;" ></p>
<p>La figure ci-dessus décrit le processus d’évolution, d’identification et de correction d’incohérence d’ontologie. La première étape (processus d’évolution) est la modification de l’ontologie de base Vn en ajoutant ou en supprimant des propriétés ou des concepts. L’étape suivante (processus d’identification) gère la cohérence de l’ontologie en utilisant le model checker NuSMV. Si une incohérence est détectée, le model checker retournera un contre-exemple affichant la séquence des modifications dans le graphe NuSMV provoquant l’incohérence. Sinon le model checker retournera « vrai » et le processus passera à la dernière étape : la validation. La troisième étape (processus de correction) est utile lorsque le model checker détecte une incohérence, cette étape corrige l’incohérence avant la mise en œuvre de la nouvelle version de l’ontologie et repassera par l’étape deux du processus pour s’assurer de l’inexistence de l’incohérence. Si après vérification, l’incohérence a disparu, on passe à l’étape de validation qui est la dernière étape de ce processus afin de valider la nouvelle version Vn+1 de l’ontologie. Sinon le processus boucle sur l’étape trois pour corriger l’incohérence jusqu&rsquo;à ce que l’incohérence disparaisse.</p>
<p>La taille et la complexité des ontologies rendent impossible une gestion manuelle des effets des changements. Pour la détection des inconsistances, nous avons besoin d’un mécanisme de détection automatique. Dans notre approche de détection des inconsistances lors de l’évolution de l’ontologie on utilisera l’approche procédurale. Cette approche garde la trace de changement entre deux versions d’ontologie qui permet de vérifier les modifications effectuées pendant l’évolution de l’ontologie. Les modifications effectuées constituent une suite d’opérations simple et/ou composite que l’utilisateur souhaite appliquer sur le schéma (voir les parties « processus d’évolution » et « processus de correction » de la figure ci-dessus). Les opérateurs simples représentent des opérations comme des ajouts ou des suppressions de relation ou de concepts. Les opérateurs complexes sont une suite d’opérations simples.
En se basant sur les techniques du model checking et des formules de la logique temporelle, nous détecterons les inconsistances dans l’évolution d’ontologie provoquées par les opérateurs simples et/ou complexes en vérifiant juste les changements (des logs) effectués pendant le processus d’évolutions de l’ontologie de base. La méthodologie CLOCk intervient dans l’étape « sémantique des changements » du processus d’évolution. L’ontologie doit évoluer d’un état consistant vers un autre état consistant, c’est-à-dire l’état où les contraintes du modèle ontologique sont respectées. Afin de résoudre les inconsistances introduites par les changements, d’autres changements additionnels peuvent être nécessaires, la tâche de cette étape étant alors de permettre la résolution de tous les changements additionnels d’une manière systématique.</p>
<p><img src="/images/projects/scalesem/clock.png" alt="" style="display: block; margin-left: auto; margin-right: auto;height: 460px !important;width: 617px !important;" ></p>
<p>La stratégie de vérification est automatique et se base sur l&rsquo;utilsation des patrons de changements pour la vérification d’incohérences (Figure ci-dessus). Cette méthodologie peut être appliquée sur l’ontologie pour une vérification a posteriori ou a priori en assurant la cohérence logique et structurelle de l’ontologie.</p>
<p>Une des tâches des raisonneurs comme <a href="">Fact++</a> ou <a href="">Pellet</a> est de valider la cohérence du modèle associé à l’ontologie. Notre méthodologie a été testée avec différents raisonneurs. <a href="">RacerPro</a> et <a href="">Pellet</a> ne permettent pas d’identifier les axiomes impliqués dans l’inconsistance soulevée. Ils donnent simplement un indice afin d&rsquo;aider l&rsquo;utilisateur à déboguer l&rsquo;ontologie. Cependant cette explication est trop vague pour que l’utilisateur comprenne entièrement la raison de l&rsquo;inconsistance. <a href="">Hermit</a> et <a href="">Fact++</a> identifient l&rsquo;incohérence comme un problème au niveau des individus (« Bad Individuals »), ce qui signifie que la contradiction se trouve dans les instances de l’ontologie. Ils donnent une liste d’axiomes liés à l&rsquo;incohérence. Cependant, comme il n&rsquo;y a pas de log d&rsquo;évolution permettant de récupérer la chronologie des axiomes, les axiomes ne peuvent pas être énumérés dans un ordre chronologique. Il n&rsquo;est donc pas possible d&rsquo;identifier lequel d’entre eux a causé la contradiction. La méthodologie CLOCk identifie l’incohérence provoquée lors de l’évolution de l’ontologie grâce au model checker et grâce au log d’évolution traçant la chronologie des axiomes.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Le W3C a pour fonction principale de standardiser la représentation et l&rsquo;échange d&rsquo;informations sur le Web. Cet objectif devrait contribuer à rendre l&rsquo;information compréhensible pour les procédés automatisés et les utilisateurs. De nouvelles normes ont été développées afin de permettre la représentation sémantique de l&rsquo;information sous forme de langages dérivés du XML. Cette base est appelée web sémantique. Ce dernier est généralement représenté comme un empilement de langages allant des langages orientés des processus automatiques aux langages représentant des concepts plus abstraits de la sémantique formelle.</p>
<p>Plusieurs langages ont été développés dans le cadre du web sémantique et la plupart de ces langages sont basés sur le langage XML. Le langage OWL et le langage RDF sont des langages très importants du web sémantique. Le langage OWL permet de représenter les ontologies, et il propose aux machines une grande capacité d’exécution du contenu Web. Le RDF est le premier standard du
W3C pour l&rsquo;enrichissement des ressources sur le Web avec des descriptions détaillées. Ces langages sont utilisés pour représenter la sémantique associée à l&rsquo;information, quelles que soient sa forme et sa structure sous la forme de graphes. Pour permettre la construction de graphes sémantiques, de nombreux outils ont été développés comme Annotea, qui est un projet du W3C qui spécifie l&rsquo;infrastructure pour l&rsquo;annotation des documents Web. Le principal format utilisé dans l&rsquo;annotation est RDF et les types de documents peuvent être annotés sont des documents basés sur HTML ou XML. Cependant, aucune n’offre la possibilité de vérifier la cohérence de la sémantique et de réduire les erreurs d&rsquo;annotations.</p>
<p>Le web sémantique, calqué sur le monde réel, est un environnement dynamique en constante évolution. Cette évolution requiert de répercuter les changements sur les ontologies du web sémantique. De par sa nature, une ontologie est en constante évolution. Tout changement peut mener à des contradictions au sein de l’ontologie. Il est donc indispensable de vérifier l’ontologie.
Ces contradictions apparaissent pour plusieurs raisons telles que des erreurs de modélisation lors de la construction d&rsquo;une ontologie ou lors de sa migration ou lors de fusion d&rsquo;ontologies. L’évolution d’une ontologie est, de l’avis de la communauté, une démarche composée de plusieurs étapes. L’une d’elles, l’étape de changement, consiste à modifier l’ontologie pour la rendre plus précise et plus adéquate au domaine qu’elle modélise. Ce processus d’enrichissement, tout comme le processus de peuplement d’ontologie et une source et un révélateur d’incohérences. Conduire l’application des changements tout en maintenant la cohérence de l’ontologie est une tâche cruciale et coûteuse en termes de temps et de complexité. Un processus automatisé est donc essentiel.</p>
<p>L’objectif de cette thèse de doctorat est de considérer les graphes sémantiques comme des graphes d’état sur lesquels des techniques de model checking peuvent être appliqués. Notre ambition était de développer une nouvelle approche et des outils, tout d’abord, pour parcourir plus rapidement les graphes sémantiques, ensuite, pour proposer un système de requêtes plus simple dans son écriture, mais offrant une plus grande couverture fonctionnelle que les langages de requêtes existants, enfin, pour vérifier la cohérence des ontologies lors de leur évolution.</p>
<p>Pour répondre à ces attentes, nous avons développé un ensemble basé sur l’utilisation d’une méthode formelle : le model checking. Le model checking est une technique très puissante et très précise dans la détection d’erreurs dans les systèmes complexes. Il peut révéler des erreurs qui n&rsquo;ont pas été découvertes par les autres méthodes formelles telles que les essais et la simulation. Il peut aussi gérer des problèmes complexes avec de grandes quantités d&rsquo;informations, stockées sous forme
de graphe.</p>
<p>Dans ce travail, nous avons tout d’abord développé des outils pour transformer les graphes sémantiques dans des modèles afin d&rsquo;être vérifiés par le model checker. Les outils RDF2SPIN et RDF2NuSMV transforment les graphes sémantiques en langage PROMELA et en langage NuSMV respectivement. Nous utilisons le model checker SPIN et le model checker NuSMV pour vérifier les modèles des graphes sémantiques. SPIN est un outil logiciel pour la vérification de modèles de systèmes. Le système est décrit dans un modèle en langage appelé PROMELA. NuSMV est l&rsquo;amélioration du model checker SMV, il travaille sur les mêmes principes que SMV. SPIN vérifie l&rsquo;exactitude des propriétés exprimées en logique temporelle linéaire, alors que NuSMV vérifie les propriétés à la fois en logique temporelle linéaire et arborescente. Une étude sur le comportement de ces outils a démontré que l’outil RDF2SPIN a plusieurs limites par rapport à RDF2NuSMV. Le model checker SPIN n’utilise que la logique temporelle linéaire et les modèles des graphes sémantiques qui peuvent être traités ne doivent pas dépasser une taille limite de 255 nœuds (états). Suite à cette étude, la suite de nos travaux s’est basée sur le model checker NuSMV. Les graphes RDF traités dans nos travaux sont présentés sous forme de fichiers XML. Leur format n’est pas toujours compatible avec l’organisation attendue par le model checker NuSMV (absence de racine). Nous avons développé un algorithme de conversion qui s&rsquo;articule en trois étapes : une étape d’exploration du graphe RDF, une étape pour la détermination d&rsquo;un sommet racine et une étape pour la génération du modèle représentant le graphe RDF.</p>
<p>Une fois que nous avons obtenu un système de traitement des graphes sémantiques par le model checker NuSMV, nous avons travaillé sur la conception d’un langage de requêtes spécifique à notre système. Notre objectif de recherche dans cette partie a été de définir un langage de requêtes simple, puissant et expressif pour les graphes sémantiques. Nous avons utilisé comme base le langage de requêtes SPARQL. Nous avons étendu ce langage avec les opérateurs des propriétés en logique temporelle permettant de combler certaines limites de SPARQL dans les graphes sémantiques (l’expression des chemins entre deux états). Sur ce point notre approche est satisfaisante. Par contre, sur de nombreux points nos performances restent tributaires de la structure des graphes et des types de requêtes. Pour l’instant, nos performances ne sont pas satisfaisantes au regard de celles de SPARQL.</p>
<p>Le dernier point de notre travail concerne l’étude des problèmes de la gestion des changements d’une ontologie. Sur ce point, nous avons proposé une nouvelle méthodologie nommée CLOCk (Change Log Ontology Checker) basée sur le model checking. Elle s’appuie sur une modélisation à l’aide de patrons d’inconsistances pour la détection et la correction de l’incohérence provoqués pendant le processus d’évolution d’ontologie. Pour être plus précis, notre approche permet la prédiction et l&rsquo;identification des patrons de succession de changement incompatibles dans le journal ou le log d’évolutions. Plusieurs études ont montré l&rsquo;importance de l&rsquo;évolution d’ontologie. Néanmoins, presque toutes ces approches ne gèrent les changements. Ce processus d’identification s&rsquo;articule en trois phases. La première phase consiste à transformer le log d’évolutions (un fichier pour la traçabilité des évolutions), spécifié en langage OWL-DL, en un graphe NuSMV. Le graphe NuSMV est composé de nœuds représentant les axiomes tracés dans le log et les arcs définissant les relations de succession entre eux. Les modifications sont représentées chronologiquement dans le modèle NuSMV. La deuxième phase génère des motifs d’incohérence. Tout d’abord, ces motifs sont extraits des patrons d’incohérences correspondants aux constructeurs utilisés dans les axiomes et sont spécifiés en logique temporelle. Ensuite, un algorithme les instancie avec les éléments du graphe NuSMV (concepts, propriétés, etc.) afin de générer tous les motifs d’incohérences pouvant figurer dans la chronologie des axiomes. Ces patrons d’incohérences définissent des règles d’instanciation spécifiées par l’attribut « hasInstanciationRule » pour chaque paramètre. Ce sont ces règles qui vont permettre de guider l’instanciation des motifs avec les éléments de la chronologie d’axiome. La troisième et dernière phase utilise le model checker NuSMV pour vérifier si un des motifs définis précédemment en logique temporelle peut être localisé dans le graphe NuSMV. Pour cela les motifs générés en logique temporelle lui sont fournis en entrée, ainsi que le graphe NuSMV.Le model checker parcourt le graphe chronologiquement de nœud en nœud afin de trouver une succession de nœuds correspondant à l&rsquo;un des motifs incohérents. Les nœuds ne doivent pas nécessairement être directement voisins successifs pour correspondre à un motif, ils ont juste besoin d&rsquo;apparaître chronologiquement dans le même ordre.</p>
<p>Notre stratégie de vérification est automatique et consiste à utiliser des patrons de changements pour la vérification d’incohérences. La méthodologie CLOCk peut être appliquée sur l’ontologie pour une vérification a posteriori ou a priori en assurant la cohérence logique et structurelle de l’ontologie.</p>
<p>L’utilisation d’un model checker pour la gestion de graphes sémantiques est une approche innovante qui n’a, à notre connaissance jamais été traitées par d’autres chercheurs. Pendant ces trois années, nous avons identifié plusieurs limites à cette approche.</p>
<p>En pratique la limitation majeure du model checking est la taille gigantesque des systèmes de transitions due au phénomène de l’explosion combinatoire du nombre d’états du système. Ce phénomène est dû, d’une part à la taille du système de transitions qui augmente exponentiellement avec le nombre de variables, et d’autre part au nombre de composants du système dans le cas où le système est concurrent. Pour limiter chacune de ces sources potentielles d’explosion combinatoire nous avons utilisé le model checker symbolique NuSMV. Le principe du model checking symbolique est d’utiliser une représentation symbolique de l’automate à vérifier. C’est-à-dire que les états sont manipulés par paquets au lieu d’être considérés un par un. Pour cela, l’algorithme utilise des fonctions booléennes sous la forme de BDD21 en tant que représentation interne. Le model checking symbolique limite le nombre de variables et les ordres partiels pour les entrelacements de composants. Ceci augmentera les ressources de calcul permettant l’utilisation industrielle du model checking pour certains types d’application. Malgré cette utilisation de NuSMV, la taille des graphes sémantique est souvent une limite. Pour répondre à cette limite et gagner de la place en mémoire, nous souhaitons d’une part réduire le nom des variables définies dans le modèle NuSMV et d’autre part développer un outil de fragmentation du graphe sémantique avant sa transformation pour traiter en parallèle les graphes sémantiques.</p>
<p>Dans notre travail, nous avons cherché à étendre le langage SPARQL. SPARQL est un langage de requête pour le Web sémantique qui a été standardisé par le W3C. Évaluer les requêtes SPARQL est connu pour être un problème de complexité NP-difficile (Pérez et al., 2009). Nous avons utilisé les algorithmes du model checking pour interroger les graphes sémantiques afin d’augmenter l’expressivité du langage de requête SPARQL. Pour cela, nous avons proposé un nouveau langage d’interrogation de graphes sémantiques basés sur l’approche ScaleSem. Ce langage utilise les opérateurs de la logique temporelle pour nous permettre un déplacement dans le graphe sémantique. Nous avons montré que les requêtes en logique temporelle sont plus simples et ont une plus grande expressivité en comparaison du langage de requête SPARQL. Néanmoins, le temps d’exécution de ces requêtes reste supérieur à celles équivalentes en SPARQL. La définition d’une syntaxe des requêtes en logique temporelle pour le web sémantique avec des temps de réponse acceptables est un challenge pour les prochaines années. Nous pourrons améliorer notre outil STL Resolver pour répondre à ces objectifs.</p>
<p>La méthodologie CLOCk proposée dans ce travail fonctionne sur de petits graphes. L’augmentation de la taille de l’ontologie provoque automatiquement l’augmentation du nombre d’instanciations des patrons d’incohérences. Ces patrons correspondent aux constructeurs utilisés dans les axiomes et sont spécifiés en logique temporelle. Nous avons décrit une stratégie pour détecter des incohérences au cours de son évolution. Notre stratégie améliore l’efficacité du processus d’évolution d’ontologie en proposant un ensemble d’actions prédéfinies à exécuter par le concepteur d’ontologie. Cette méthodologie est une mise en œuvre de notre approche ScaleSem dans le domaine de l’évolution d’ontologie. Notre objectif futur est de faire de cette méthodologie un débuggeur d’ontologie plus précis et plus rapide que les raisonneurs d’ontologie connu comme Pellet, Fact++.</p>
<h2 id="publications">Publications</h2>
<h4 id="livre">Livre</h4>
<ul>
<li>Gueffaz, M., Rampacek, S. et Nicolle, C. <em>ScaleSem: a new approach to check and to query semantic graphs</em>. IGI Global, Encyclopedia Editorial Team, 2012</li>
</ul>
<h4 id="journal">Journal</h4>
<ul>
<li>
<p>Gueffaz, M., Rampacek, S. et Nicolle, C., <em>Temporal Logic to Query Semantic Graphs Based on the NuSMV model checker</em>, Journal of Software (JSW), Selected Best papers on IIT, 2012</p>
</li>
<li>
<p>Gueffaz, M., Rampacek, S. et Nicolle, C., <em>Mapping SPARQL Query to Temporal Logic Query Based on NμSMV model checker to Query Semantic Graphs</em>, International Journal of Digital Information and Wireless Communications (IJDIWC) 1, 2 (2012) 366-380, 2012</p>
</li>
<li>
<p>Gueffaz, M., Rampacek, S. et Nicolle, C., <em>Verifying Semantic Graphs With the model checker SPIN</em>, International Journal of Digital Information and Wireless Communications (IJDIWC) 1, 1 (2011) 64-74, 2011</p>
</li>
</ul>
<h4 id="conféérences-internatonnales">Conféérences internatonnales</h4>
<ul>
<li>
<p>Gueffaz, M., Rampacek, S. et Nicolle, C., <em>Inconsistency Identification In Dynamic Ontologies Based On Model checking</em>, Webist 2012- Proceedings  of the the 8th International Conference on Web Information Systems and Technologies , Porto, Portugal, INSTICC, ACM SIGMIS, May 2011</p>
</li>
<li>
<p>Gueffaz, M., Rampacek, S. et Nicolle, C., <em>RDF2NµSMV: Mapping Semantic Graphs to NµSMV model checker</em>, Proceedings of the Third International Conference on Advances in Future Internet (AFIN 2011), Nice/Saint Laurent du Var, France, Août 2011</p>
</li>
<li>
<p>Gueffaz, M., Rampacek, S. et Nicolle, C., <em>A New Approach Based on NµSMV Model to Query Semantic Graph</em>, Proceedings of the International Conference on Digital Information Processing and Communications (ICDIPC 2011), Ostrava, République Tchèque, Springer-Verlag, Juillet 2011</p>
</li>
<li>
<p>Gueffaz, M., Rampacek, S. et Nicolle, C., <em>RDF2SPIN: Mapping Semantic Graphs To Spin model checker</em>, Proceedings of the International Conference on Digital Information and Communication Technology (DICTAP), Dijon, France, Springer-Verlag, 21 Juin 2011</p>
</li>
<li>
<p>Gueffaz, M., Rampacek, S. et Nicolle, C., <em>Scalesem: Evaluation Of Semantic Graph Based On Model checking</em>, Webist 2011- Proceedings of the 7th International Conference on Web Information Systems and Technologies, Noordwijkerhout, Hollande, INSTICC, ACM SIGMIS, May 2011</p>
</li>
<li>
<p>Gueffaz, M., Rampacek, S. et Nicolle, C., <em>Qualifying Semantic Graphs Using Model checking</em>, Proceedings of the of the 7th International Conference on Innovations in Information Technology (Innovations'11), Abu Dhabi, Emirats arabes Unis, Sponsored by IEEE, April 2011</p>
</li>
</ul>
<h4 id="séminaires">Séminaires</h4>
<ul>
<li>
<p>Gueffaz, M., Rampacek, S. et Nicolle, C., <em>La logique temporelle pour interroger et qualifier des graphes sémantiques</em>, Réseau Grand Est (RGE), Strasbourg, France, 13 octobre 2011</p>
</li>
<li>
<p>Gueffaz, M., Qualification et interrogation de graphes sémantiques à l&rsquo;aide du Model checking, Assemblé général du laboratoire LE2I, Creusot (Centre universitaire du Condorcet), France, 1 juillet 2011</p>
</li>
<li>
<p>Gueffaz, M., Rampacek, S. et Nicolle, C., <em>Qualification de graphes sémantiques à l&rsquo;aide du Model checking</em>, 17eme Forum des jeunes
chercheurs (FJC 2011), Dijon, France, 16 et 17 Juin 2011</p>
</li>
<li>
<p>Gueffaz, M., <em>L&rsquo;interrogation des graphes sémantiques à l&rsquo;aide de la logique temporelle</em>, Séminaire Université de Franche-Comté., Besançon, France, Juillet 2010</p>
</li>
</ul>
<h4 id="dépot-app">Dépot APP</h4>
<ul>
<li>
<p>SPARQL2RLT: IDDN FR.001.240031.000.S.P.2012.000.10800. Outil de transformation de requêtes SPARQL en requête utilisant la logique temporelle.</p>
</li>
<li>
<p>STL-Resolver: IDDN FR.001.240032.000.SP.2012.000.10800. Outil de résolution des requêtes en logique temporelle.</p>
</li>
<li>
<p>RDF2SPIN : IDDN FR.001.240034.000.SP.2012.000.10800. Outil de transformation de graphes RDF en modèles de graphe SPIN.</p>
</li>
<li>
<p>RDF2NuSMV: IDDN FR.001.240040.000.S.P.2012.000.10800. Outil de transformation de graphes RDF en modèles de graphe NuSMV.</p>
</li>
</ul>
<h2 id="liens">Liens</h2>
<p>Pour plus d&rsquo;information, veuillez visiter le site du rapport de thèse sur le lien suivant <a href="https://hal.archives-ouvertes.fr/tel-00801730">ici</a> et sur les differentes publications <a href="https://dblp.org/pid/38/9810.html">ici</a></p>
<h2 id="remerciements">Remerciements</h2>
<ul>
<li>
<p>Perrine Pittet pour sa collaboration au projet CLOCK.</p>
</li>
<li>
<p>Christophe Nicolle de m&rsquo;avoir accuillie dans son équipe de recherche à l&rsquo;Université de Bourgogne.</p>
</li>
</ul>

      </div>


      <footer>
        

<section class="see-also">
  
    
    
    
      <h3>Voir aussi dans Theme</h3>
      <nav>
        <ul>
        
        
          
            <li>
              <a href="/fr/projects/coronavirus-tracker/">Coronavirus tracker</a>
            </li>
          
        
          
            <li>
              <a href="/fr/projects/ilot/">Ilot</a>
            </li>
          
        
          
        
        </ul>
      </nav>
    
  
    
    
    
      <h3>Voir aussi dans Hugo</h3>
      <nav>
        <ul>
        
        
          
            <li>
              <a href="/fr/projects/coronavirus-tracker/">Coronavirus tracker</a>
            </li>
          
        
          
            <li>
              <a href="/fr/projects/ilot/">Ilot</a>
            </li>
          
        
          
        
        </ul>
      </nav>
    
  
</section>


        <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "yourdiscussshortname" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
        
        
      </footer>
    </article>

    
  </section>

      </div>

      
  <footer class="footer">
    <section class="container">
      
      
        ©
        
        2020
         Mahdi GUEFFAZ 
      
      
      
    </section>
  </footer>


    </main>

    
      
        
        <script src="/js/dark-mode.min.a174f322143153d519c8f11b22942a76d356dc40eddd4948f983cb2c3b1ba285.js"></script>
      
    

    

    

    <script>
(function(f, a, t, h, o, m){
	a[h]=a[h]||function(){
		(a[h].q=a[h].q||[]).push(arguments)
	};
	o=f.createElement('script'),
	m=f.getElementsByTagName('script')[0];
	o.async=1; o.src=t; o.id='fathom-script';
	m.parentNode.insertBefore(o,m)
})(document, window, '//analytics.example.com/tracker.js', 'fathom');
fathom('set', 'siteId', 'ABCDE');
fathom('trackPageview');
</script>


    <script async defer data-domain="example.com" src="https://analytics.example.com/js/plausible.js"></script>


    <script data-goatcounter="https://code.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>

  </body>

</html>
